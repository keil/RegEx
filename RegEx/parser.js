/*
 * Efficient Solving of Regular Expression Inequalities 
 *  Regular Expression Generator
 *
 * Copyright (c) 2013, Proglang, University of Freiburg.
 *  http://proglang.informatik.uni-freiburg.de/
 * All rights reserved.
 *
 * Author Matthias Keil
 *  http://www.informatik.uni-freiburg.de/~keilr/
 *
 * $Date: 2013-07-23 15:59:13 +0200 (Tue, 23 Jul 2013) $
 * $Rev: 23389 $
 */

/**
 * Powered by: http://pegjs.majda.cz/online
 */

__RegEx.Parser = (function(){

		// basic literals
		var Atom		= __RegEx.Literal.Atom;
		var Set			= __RegEx.Literal.Set;
		var Inv			= __RegEx.Literal.Inv;
		
		// predefined character classes
		var Digit		= __RegEx.Literal.Digit;
		var Char		= __RegEx.Literal.Char;
		var LowerChar	= __RegEx.Literal.LowerChar;
		var UpperChar	= __RegEx.Literal.UpperChar;
		var Alpha		= __RegEx.Literal.Alpha;
		var Wildcard	= __RegEx.Literal.Wildcard;

		// expressions
		var Empty	= __RegEx.Expression.Empty;
		var Null	= __RegEx.Expression.Null;
		var Star	= __RegEx.Expression.Star;
		var Or		= __RegEx.Expression.Or;
		var And		= __RegEx.Expression.And;
		var Neg		= __RegEx.Expression.Neg;
		var Dot		= __RegEx.Expression.Dot;

		/*
		 * Generated by PEG.js 0.7.0.
		 *
		 * http://pegjs.majda.cz/
		 */

		function quote(s) {
				/*
				 * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
				 * string literal except for the closing quote character, backslash,
				 * carriage return, line separator, paragraph separator, and line feed.
				 * Any character may appear in the form of an escape sequence.
				 *
				 * For portability, we also escape escape all control and non-ASCII
				 * characters. Note that "\0" and "\v" escape sequences are not used
				 * because JSHint does not like the first and IE the second.
				 */
				return '"' + s
						.replace(/\\/g, '\\\\')  // backslash
						.replace(/"/g, '\\"')    // closing quote character
						.replace(/\x08/g, '\\b') // backspace
						.replace(/\t/g, '\\t')   // horizontal tab
						.replace(/\n/g, '\\n')   // line feed
						.replace(/\f/g, '\\f')   // form feed
						.replace(/\r/g, '\\r')   // carriage return
						.replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
						+ '"';
		}

		var result = {
				/*
				 * Parses the input with a generated parser. If the parsing is successfull,
				 * returns a value explicitly or implicitly specified by the grammar from
				 * which the parser was generated (see |PEG.buildParser|). If the parsing is
				 * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
				 */
				parse: function(input, startRule) {
						var parseFunctions = {
								"Expression": parse_Expression,
								"Dot": parse_Dot,
								"Neg": parse_Neg,
								"And": parse_And,
								"Or": parse_Or,
								"Star": parse_Star,
								"Bracketing": parse_Bracketing,
								"Literal": parse_Literal,
								"Character": parse_Character,
								"csDigit": parse_csDigit,
								"csChar": parse_csChar,
								"csUpperChar": parse_csUpperChar,
								"csLowerChar": parse_csLowerChar,
								"csAlpha": parse_csAlpha,
								"csWildcard": parse_csWildcard,
								"Set": parse_Set,
								"Inv": parse_Inv,
								"Digit": parse_Digit,
								"Char": parse_Char,
								"UpperChar": parse_UpperChar,
								"LowerChar": parse_LowerChar,
								"Alpha": parse_Alpha,
								"Wildcard": parse_Wildcard
						};

						if (startRule !== undefined) {
								if (parseFunctions[startRule] === undefined) {
										throw new Error("Invalid rule name: " + quote(startRule) + ".");
								}
						} else {
								startRule = "Expression";
						}

						var pos = 0;
						var reportFailures = 0;
						var rightmostFailuresPos = 0;
						var rightmostFailuresExpected = [];

						function padLeft(input, padding, length) {
								var result = input;

								var padLength = length - input.length;
								for (var i = 0; i < padLength; i++) {
										result = padding + result;
								}

								return result;
						}

						function escape(ch) {
								var charCode = ch.charCodeAt(0);
								var escapeChar;
								var length;

								if (charCode <= 0xFF) {
										escapeChar = 'x';
										length = 2;
								} else {
										escapeChar = 'u';
										length = 4;
								}

								return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
						}

						function matchFailed(failure) {
								if (pos < rightmostFailuresPos) {
										return;
								}

								if (pos > rightmostFailuresPos) {
										rightmostFailuresPos = pos;
										rightmostFailuresExpected = [];
								}

								rightmostFailuresExpected.push(failure);
						}

						function parse_Expression() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_Dot();
								if (result0 !== null) {
										result0 = (function(offset, r) { return r; })(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Dot() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								result0 = parse_Neg();
								if (result0 !== null) {
										if (input.charCodeAt(pos) === 46) {
												result1 = ".";
												pos++;
										} else {
												result1 = null;
												if (reportFailures === 0) {
														matchFailed("\".\"");
												}
										}
										if (result1 !== null) {
												result2 = parse_Dot();
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r, s) { return Dot(r,s); })(pos0, result0[0], result0[2]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Neg();
										if (result0 !== null) {
												result0 = (function(offset, r) { return r; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
										if (result0 === null) {
												pos0 = pos;
												result0 = parse_Literal();
												if (result0 !== null) {
														result0 = (function(offset, l) {return l; })(pos0, result0);
												}
												if (result0 === null) {
														pos = pos0;
												}
										}
								}
								return result0;
						}

						function parse_Neg() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								if (input.charCodeAt(pos) === 33) {
										result1 = "!";
										pos++;
								} else {
										result1 = null;
										if (reportFailures === 0) {
												matchFailed("\"!\"");
										}
								}
								if (result1 !== null) {
										result0 = [];
										while (result1 !== null) {
												result0.push(result1);
												if (input.charCodeAt(pos) === 33) {
														result1 = "!";
														pos++;
												} else {
														result1 = null;
														if (reportFailures === 0) {
																matchFailed("\"!\"");
														}
												}
										}
								} else {
										result0 = null;
								}
								if (result0 !== null) {
										result1 = parse_And();
										if (result1 !== null) {
												result2 = "";
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r) { return Neg(r); })(pos0, result0[1]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_And();
										if (result0 !== null) {
												result0 = (function(offset, r) { return r; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
								}
								return result0;
						}

						function parse_And() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								result0 = parse_Or();
								if (result0 !== null) {
										if (input.charCodeAt(pos) === 38) {
												result1 = "&";
												pos++;
										} else {
												result1 = null;
												if (reportFailures === 0) {
														matchFailed("\"&\"");
												}
										}
										if (result1 !== null) {
												result2 = parse_And();
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r, s) { return And(r, s); })(pos0, result0[0], result0[2]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Or();
										if (result0 !== null) {
												result0 = (function(offset, r) { return r; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
								}
								return result0;
						}

						function parse_Or() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								result0 = parse_Star();
								if (result0 !== null) {
										if (input.charCodeAt(pos) === 43) {
												result1 = "+";
												pos++;
										} else {
												result1 = null;
												if (reportFailures === 0) {
														matchFailed("\"+\"");
												}
										}
										if (result1 !== null) {
												result2 = parse_Or();
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r, s) { return Or(r, s); })(pos0, result0[0], result0[2]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Star();
										if (result0 !== null) {
												result0 = (function(offset, r) { return r; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
								}
								return result0;
						}

						function parse_Star() {
								var result0, result1;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								result0 = parse_Bracketing();
								if (result0 !== null) {
										if (input.charCodeAt(pos) === 42) {
												result1 = "*";
												pos++;
										} else {
												result1 = null;
												if (reportFailures === 0) {
														matchFailed("\"*\"");
												}
										}
										if (result1 !== null) {
												result0 = [result0, result1];
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r) { return Star(r); })(pos0, result0[0]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Bracketing();
										if (result0 !== null) {
												result0 = (function(offset, r) { return r; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
								}
								return result0;
						}

						function parse_Bracketing() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								if (input.charCodeAt(pos) === 40) {
										result0 = "(";
										pos++;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"(\"");
										}
								}
								if (result0 !== null) {
										result1 = parse_Dot();
										if (result1 !== null) {
												if (input.charCodeAt(pos) === 41) {
														result2 = ")";
														pos++;
												} else {
														result2 = null;
														if (reportFailures === 0) {
																matchFailed("\")\"");
														}
												}
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, r) { return r; })(pos0, result0[1]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Literal();
										if (result0 !== null) {
												result0 = (function(offset, l) {return l; })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
								}
								return result0;
						}

						function parse_Literal() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_Character();
								if (result0 !== null) {
										result0 = (function(offset, l) { return Atom(l); })(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								if (result0 === null) {
										pos0 = pos;
										result0 = parse_Digit();
										if (result0 !== null) {
												result0 = (function(offset, l) { return Digit(l); })(pos0, result0);
										}
										if (result0 === null) {
												pos = pos0;
										}
										if (result0 === null) {
												pos0 = pos;
												result0 = parse_Char();
												if (result0 !== null) {
														result0 = (function(offset, l) { return Char(l); })(pos0, result0);
												}
												if (result0 === null) {
														pos = pos0;
												}
												if (result0 === null) {
														pos0 = pos;
														result0 = parse_UpperChar();
														if (result0 !== null) {
																result0 = (function(offset, l) { return UpperChar(l); })(pos0, result0);
														}
														if (result0 === null) {
																pos = pos0;
														}
														if (result0 === null) {
																pos0 = pos;
																result0 = parse_LowerChar();
																if (result0 !== null) {
																		result0 = (function(offset, l) { return LowerChar(l); })(pos0, result0);
																}
																if (result0 === null) {
																		pos = pos0;
																}
																if (result0 === null) {
																		pos0 = pos;
																		result0 = parse_Alpha();
																		if (result0 !== null) {
																				result0 = (function(offset, l) { return Alpha(l); })(pos0, result0);
																		}
																		if (result0 === null) {
																				pos = pos0;
																		}
																		if (result0 === null) {
																				pos0 = pos;
																				result0 = parse_Set();
																				if (result0 !== null) {
																						result0 = (function(offset, l) { return Set(l); })(pos0, result0);
																				}
																				if (result0 === null) {
																						pos = pos0;
																				}
																				if (result0 === null) {
																						pos0 = pos;
																						result0 = parse_Inv();
																						if (result0 !== null) {
																								result0 = (function(offset, l) { return Inv(l); })(pos0, result0);
																						}
																						if (result0 === null) {
																								pos = pos0;
																						}
																						if (result0 === null) {
																								pos0 = pos;
																								result0 = parse_Wildcard();
																								if (result0 !== null) {
																										result0 = (function(offset, l) { return Wildcard(); })(pos0, result0);
																								}
																								if (result0 === null) {
																										pos = pos0;
																								}
																						}
																				}
																		}
																}
														}
												}
										}
								}
								return result0;
						}

						function parse_Character() {
								var result0;
								var pos0;

								pos0 = pos;
								if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
										result0 = input.charAt(pos);
										pos++;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("[a-zA-Z0-9]");
										}
								}
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_csDigit() {
								var result0;

								if (input.substr(pos, 7) === "[digit]") {
										result0 = "[digit]";
										pos += 7;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[digit]\"");
										}
								}
								return result0;
						}

						function parse_csChar() {
								var result0;

								if (input.substr(pos, 6) === "[char]") {
										result0 = "[char]";
										pos += 6;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[char]\"");
										}
								}
								return result0;
						}

						function parse_csUpperChar() {
								var result0;

								if (input.substr(pos, 7) === "[uchar]") {
										result0 = "[uchar]";
										pos += 7;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[uchar]\"");
										}
								}
								return result0;
						}

						function parse_csLowerChar() {
								var result0;

								if (input.substr(pos, 7) === "[lchar]") {
										result0 = "[lchar]";
										pos += 7;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[lchar]\"");
										}
								}
								return result0;
						}

						function parse_csAlpha() {
								var result0;

								if (input.substr(pos, 7) === "[alpha]") {
										result0 = "[alpha]";
										pos += 7;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[alpha]\"");
										}
								}
								return result0;
						}

						function parse_csWildcard() {
								var result0;

								if (input.charCodeAt(pos) === 63) {
										result0 = "?";
										pos++;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"?\"");
										}
								}
								return result0;
						}

						function parse_Set() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								if (input.charCodeAt(pos) === 91) {
										result0 = "[";
										pos++;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[\"");
										}
								}
								if (result0 !== null) {
										result1 = [];
										result2 = parse_Character();
										while (result2 !== null) {
												result1.push(result2);
												result2 = parse_Character();
										}
										if (result1 !== null) {
												if (input.charCodeAt(pos) === 93) {
														result2 = "]";
														pos++;
												} else {
														result2 = null;
														if (reportFailures === 0) {
																matchFailed("\"]\"");
														}
												}
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0[1]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Inv() {
								var result0, result1, result2;
								var pos0, pos1;

								pos0 = pos;
								pos1 = pos;
								if (input.substr(pos, 2) === "[^") {
										result0 = "[^";
										pos += 2;
								} else {
										result0 = null;
										if (reportFailures === 0) {
												matchFailed("\"[^\"");
										}
								}
								if (result0 !== null) {
										result1 = [];
										result2 = parse_Character();
										while (result2 !== null) {
												result1.push(result2);
												result2 = parse_Character();
										}
										if (result1 !== null) {
												if (input.charCodeAt(pos) === 93) {
														result2 = "]";
														pos++;
												} else {
														result2 = null;
														if (reportFailures === 0) {
																matchFailed("\"]\"");
														}
												}
												if (result2 !== null) {
														result0 = [result0, result1, result2];
												} else {
														result0 = null;
														pos = pos1;
												}
										} else {
												result0 = null;
												pos = pos1;
										}
								} else {
										result0 = null;
										pos = pos1;
								}
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0[1]);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Digit() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csDigit();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Char() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csChar();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_UpperChar() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csUpperChar();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_LowerChar() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csLowerChar();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Alpha() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csAlpha();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}

						function parse_Wildcard() {
								var result0;
								var pos0;

								pos0 = pos;
								result0 = parse_csWildcard();
								if (result0 !== null) {
										result0 = (function(offset, c) {
												return c;
										})(pos0, result0);
								}
								if (result0 === null) {
										pos = pos0;
								}
								return result0;
						}


						function cleanupExpected(expected) {
								expected.sort();

								var lastExpected = null;
								var cleanExpected = [];
								for (var i = 0; i < expected.length; i++) {
										if (expected[i] !== lastExpected) {
												cleanExpected.push(expected[i]);
												lastExpected = expected[i];
										}
								}
								return cleanExpected;
						}

						function computeErrorPosition() {
								/*
								 * The first idea was to use |String.split| to break the input up to the
								 * error position along newlines and derive the line and column from
								 * there. However IE's |split| implementation is so broken that it was
								 * enough to prevent it.
								 */

								var line = 1;
								var column = 1;
								var seenCR = false;

								for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
										var ch = input.charAt(i);
										if (ch === "\n") {
												if (!seenCR) { line++; }
												column = 1;
												seenCR = false;
										} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
												line++;
												column = 1;
												seenCR = true;
										} else {
												column++;
												seenCR = false;
										}
								}

								return { line: line, column: column };
						}




						var result = parseFunctions[startRule]();

						/*
						 * The parser is now in one of the following three states:
						 *
						 * 1. The parser successfully parsed the whole input.
						 *
						 *    - |result !== null|
						 *    - |pos === input.length|
						 *    - |rightmostFailuresExpected| may or may not contain something
						 *
						 * 2. The parser successfully parsed only a part of the input.
						 *
						 *    - |result !== null|
						 *    - |pos < input.length|
						 *    - |rightmostFailuresExpected| may or may not contain something
						 *
						 * 3. The parser did not successfully parse any part of the input.
						 *
						 *   - |result === null|
						 *   - |pos === 0|
						 *   - |rightmostFailuresExpected| contains at least one failure
						 *
						 * All code following this comment (including called functions) must
						 * handle these states.
						 */
						if (result === null || pos !== input.length) {
								var offset = Math.max(pos, rightmostFailuresPos);
								var found = offset < input.length ? input.charAt(offset) : null;
								var errorPosition = computeErrorPosition();

								throw new this.SyntaxError(
												cleanupExpected(rightmostFailuresExpected),
												found,
												offset,
												errorPosition.line,
												errorPosition.column
												);
						}

						return result;
				},

				/* Returns the parser source code. */
				toSource: function() { return this._source; }
		};

		/* Thrown when a parser encounters a syntax error. */

		result.SyntaxError = function(expected, found, offset, line, column) {
				function buildMessage(expected, found) {
						var expectedHumanized, foundHumanized;

						switch (expected.length) {
								case 0:
										expectedHumanized = "end of input";
										break;
								case 1:
										expectedHumanized = expected[0];
										break;
								default:
										expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
												+ " or "
												+ expected[expected.length - 1];
						}

						foundHumanized = found ? quote(found) : "end of input";

						return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
				}

				this.name = "SyntaxError";
				this.expected = expected;
				this.found = found;
				this.message = buildMessage(expected, found);
				this.offset = offset;
				this.line = line;
				this.column = column;
		};

		result.SyntaxError.prototype = Error.prototype;

		return result;
})();
